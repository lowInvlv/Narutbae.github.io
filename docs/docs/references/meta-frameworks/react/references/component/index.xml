<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Component on My Ship Logs</title>
    <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/</link>
    <description>Recent content in Component on My Ship Logs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/componentdidcatch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/componentdidcatch/</guid>
      <description>componentDidCatch() # componentDidCatch() # componentDidCatch(error, info) This lifecycle is invoked after an error has been thrown by a descendant component. It receives two parameters:
error - The error that was thrown. info - An object with a componentStack key containing information about which component threw the error. componentDidCatch() is called during the ‚Äúcommit‚Äù phase, so side-effects are permitted. It should be used for things like logging errors:
class ErrorBoundary extends React.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/componentdidmount/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/componentdidmount/</guid>
      <description>‚≠ê componentDidMount() # componentDidMount() # componentDidMount() componentDidMount() is invoked immediately after a component is mounted (inserted into the tree). Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request.
This method is a good place to set up any subscriptions. If you do that, don‚Äôt forget to unsubscribe in componentWillUnmount().
You may call setState() immediately in componentDidMount().</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/componentdidupdate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/componentdidupdate/</guid>
      <description>‚≠ê componentDidUpdate() # componentDidUpdate() # componentDidUpdate(prevProps, prevState, snapshot) componentDidUpdate() is invoked immediately after updating occurs. This method is not called for the initial render.
Use this as an opportunity to operate on the DOM when the component has been updated. This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed).</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/componentwillunmount/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/componentwillunmount/</guid>
      <description>componentWillUnmount() # componentWillUnmount() # componentWillUnmount() componentWillUnmount() is invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in componentDidMount().
You should not call setState() in componentWillUnmount() because the component will never be re-rendered. Once a component instance is unmounted, it will never be mounted again.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/constructor/</guid>
      <description>constructor() # constructor() # constructor(props) If you don‚Äôt initialize state and you don‚Äôt bind methods, you don‚Äôt need to implement a constructor for your React component.
The constructor for a React component is called before it is mounted. When implementing the constructor for a React.Component subclass, you should call super(props) before any other statement. Otherwise, this.props will be undefined in the constructor, which can lead to bugs.
Typically, in React constructors are only used for two purposes:</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/defaultprop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/defaultprop/</guid>
      <description>defaultProp # defaultProps # defaultProps can be defined as a property on the component class itself, to set the default props for the class. This is used for undefined props, but not for null props. For example:
class CustomButton extends React.Component { // ... } CustomButton.defaultProps = { color: &amp;#39;blue&amp;#39; }; If props.color is not provided, it will be set by default to &#39;blue&#39;:
render() { return &amp;lt;CustomButton /&amp;gt; ; // props.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/displayname/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/displayname/</guid>
      <description>displayName # displayName # The displayName string is used in debugging messages. Usually, you don‚Äôt need to set it explicitly because it‚Äôs inferred from the name of the function or class that defines the component. You might want to set it explicitly if you want to display a different name for debugging purposes or when you create a higher-order component, see Wrap the Display Name for Easy Debugging for details.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/forceupdate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/forceupdate/</guid>
      <description>forceUpdate() # forceUpdate() # component.forceUpdate(callback) By default, when your component‚Äôs state or props change, your component will re-render. If your render() method depends on some other data, you can tell React that the component needs re-rendering by calling forceUpdate().
Calling forceUpdate() will cause render() to be called on the component, skipping shouldComponentUpdate(). This will trigger the normal lifecycle methods for child components, including the shouldComponentUpdate() method of each child. React will still only update the DOM if the markup changes.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/getsnapshotbeforeupdate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/getsnapshotbeforeupdate/</guid>
      <description>getSnapshotBeforeUpdate() # getSnapshotBeforeUpdate() # getSnapshotBeforeUpdate(prevProps, prevState) getSnapshotBeforeUpdate() is invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to componentDidUpdate().
This use case is not common, but it may occur in UIs like a chat thread that need to handle scroll position in a special way.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/props/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/props/</guid>
      <description>üåµ props # props # this.props contains the props that were defined by the caller of this component. See Components and Props for an introduction to props.
In particular, this.props.children is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/render/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/render/</guid>
      <description>‚≠ê render() # render() # render() The render() method is the only required method in a class component.
When called, it should examine this.props and this.state and return one of the following types:
React elements. Typically created via JSX. For example, &amp;lt;div /&amp;gt; and &amp;lt;MyComponent /&amp;gt; are React elements that instruct React to render a DOM node, or another user-defined component, respectively. Arrays and fragments. Let you return multiple elements from render.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/setstate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/setstate/</guid>
      <description>setState() # setState() # setState(updater[, callback]) setState() enqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. This is the primary method you use to update the user interface in response to event handlers and server responses.
Think of setState() as a request rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/shouldcomponentupdate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/shouldcomponentupdate/</guid>
      <description>shouldComponentUpdate() # shouldComponentUpdate() # shouldComponentUpdate(nextProps, nextState) Use shouldComponentUpdate() to let React know if a component‚Äôs output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior.
shouldComponentUpdate() is invoked before rendering when new props or state are being received. Defaults to true. This method is not called for the initial render or when forceUpdate() is used.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/state/</guid>
      <description>üåµ state # state # The state contains data specific to this component that may change over time. The state is user-defined, and it should be a plain JavaScript object.
If some value isn‚Äôt used for rendering or data flow (for example, a timer ID), you don‚Äôt have to put it in the state. Such values can be defined as fields on the component instance.
See State and Lifecycle for more information about the state.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/static-getderivedstatefromerror/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/static-getderivedstatefromerror/</guid>
      <description>static getDerivedStateFromError() # static getDerivedStateFromError() # static getDerivedStateFromError(error) This lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state.
class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error) { // Update state so the next render will show the fallback UI.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/static-getderivedstatefromprops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/static-getderivedstatefromprops/</guid>
      <description>static getDerivedStateFromProps() # static getDerivedStateFromProps() # static getDerivedStateFromProps(props, state) getDerivedStateFromProps is invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or null to update nothing.
This method exists for rare use cases where the state depends on changes in props over time. For example, it might be handy for implementing a &amp;lt;Transition&amp;gt; component that compares its previous and next children to decide which of them to animate in and out.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/unsafe_componentwillmount/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/unsafe_componentwillmount/</guid>
      <description>UNSAFE_componentWillMount() # UNSAFE_componentWillMount() # UNSAFE_componentWillMount() Note
This lifecycle was previously named componentWillMount. That name will continue to work until version 17. Use the rename-unsafe-lifecycles codemod to automatically update your components.
UNSAFE_componentWillMount() is invoked just before mounting occurs. It is called before render(), therefore calling setState() synchronously in this method will not trigger an extra rendering. Generally, we recommend using the constructor() instead for initializing state.
Avoid introducing any side-effects or subscriptions in this method.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/unsafe_componentwillreceiveprops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/unsafe_componentwillreceiveprops/</guid>
      <description>UNSAFE_componentWillReceiveProps() # UNSAFE_componentWillReceiveProps() # UNSAFE_componentWillReceiveProps(nextProps) Note
This lifecycle was previously named componentWillReceiveProps. That name will continue to work until version 17. Use the rename-unsafe-lifecycles codemod to automatically update your components.
Note:
Using this lifecycle method often leads to bugs and inconsistencies
If you need to perform a side effect (for example, data fetching or an animation) in response to a change in props, use componentDidUpdate lifecycle instead. If you used componentWillReceiveProps for re-computing some data only when a prop changes, use a memoization helper instead.</description>
    </item>
    <item>
      <title></title>
      <link>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/unsafe_componentwillupdate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://Narutabe.github.io/docs/references/meta-frameworks/react/references/component/unsafe_componentwillupdate/</guid>
      <description>UNSAFE_componentWillUpdate() # UNSAFE_componentWillUpdate() # UNSAFE_componentWillUpdate(nextProps, nextState) Note
This lifecycle was previously named componentWillUpdate. That name will continue to work until version 17. Use the rename-unsafe-lifecycles codemod to automatically update your components.
UNSAFE_componentWillUpdate() is invoked just before rendering when new props or state are being received. Use this as an opportunity to perform preparation before an update occurs. This method is not called for the initial render.
Note that you cannot call this.</description>
    </item>
  </channel>
</rss>
